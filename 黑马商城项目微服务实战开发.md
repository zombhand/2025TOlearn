# 黑马商城项目微服务实战开发

## 导入数据库

在黑马中导入数据使用docker进行自动化导入

```bash
docker run -d \
  --name mysql \
  -p 3307:3306 \
  -e TZ=Asia/Shanghai \
  -e MYSQL_ROOT_PASSWORD=123 \
  -v /root/mysql/data:/var/lib/mysql \
  -v /root/mysql/conf:/etc/mysql.conf.d \
  -v /root/mysql/init:/docker-entrypoint-initdb.d \
  --network hm-net \
  mysql
```

## 拆分服务

首先在父工程下新建个模块

然后把需要的依赖给引入

在新的工程的启动项上进行个注解

```java
@MapperScan("com.heima.item.mapper")
@SpringBootApplication
public class ItemServiceApplication {

    public static void main(String[] args) {
        SpringApplication.run(ItemServiceApplication.class, args);
    }

}
```

@MapperScan

作用：指定要变成实现类的接口所在的包，然后包下面的所有接口在编译之后都会生成相应的实现类

添加位置：是在SpringBoot启动类上面添加



#### 在配置中

需要注意的点:

1. 每个微服务名字各异
2. logging配置中
   1. level是输出级别
   2. fill-path 是文件的输出位置，保证每个服务的输出位置不同

```yaml
server:
  port: 8081
# 要给微服务起个名字
spring:
  application:
    name: item-service # 微服务名称
  profiles:
    active: dev
  datasource:
    url: jdbc:mysql://${hm.db.host}:3307/hmall?useUnicode=true&characterEncoding=UTF-8&autoReconnect=true&serverTimezone=Asia/Shanghai
    driver-class-name: com.mysql.cj.jdbc.Driver
    username: root
    password: ${hm.db.pw}
mybatis-plus:
  configuration:
    default-enum-type-handler: com.baomidou.mybatisplus.core.handlers.MybatisEnumTypeHandler
  global-config:
    db-config:
      update-strategy: not_null
      id-type: auto
logging:
  level:
    com.hmall: debug
  pattern:
    dateformat: HH:mm:ss:SSS
  file:
    path: "logs/${spring.application.name}"
knife4j:
  enable: true
  openapi:
    title: 黑马商城商品管理文档
    description: "黑马商城商品管理文档"
    email: zhanghuyi@itcast.cn
    concat: 虎哥
    url: https://www.itcast.cn
    version: v1.0.0
    group:
      default:
        group-name: default
        api-rule: package
        api-rule-resources:
          - com.heima.item.controller

```









# 实用的点

### 工具类

其中的BeanUtil 很好用

```xml
<dependency>
            <groupId>cn.hutool</groupId>
            <artifactId>hutool-core</artifactId>
            <version>5.8.35</version>
</dependency>
```

### mybatisplus实用插件使用

![image-20250112174704016](C:\Users\29326\AppData\Roaming\Typora\typora-user-images\image-20250112174704016.png)

### 查询集合时判空使用

```java
CollUtil.isEmpty(list);
// 为空的话返回一个
Collections.emptyList();
```



```java
// 已知ids获取对应用户
List<User> userList = listByIds(ids);
// 1获取用户id集合
List<Long> idList = userList.lambda().map(User::getId).collect(Collectors.toList());

// 2根据用户id查询地址
List<Address> address = Db.lambdaQuery(Address.class).in(Address::getUserId, userIds).list();
// 2.1获取用户id集合
List<Long> idList = userList.stream().map(User::getId).toList();
// 2.2根据用户id查询地址
List<Address> addressList = Db.lambdaQuery(Address.class).in(Address::getUserId, idList).lsit();
// 2.3转换地址VO
List<AddressVO> addressVOS = BeanUtil.copyToList(addressList, AddressVO.class);
// 2.4用户地址集合分组处理，相同用户的放入一个集合（组）中
Map<Long, List<AddressVO>> addressMap = new HashMap<>(0);
if(CollUtil.isNotEmpty(addressList)){
    addressMap = addressMap.stream().collect(Collectors.groupingBy(AddressVO::getUserId));
}
// 3.转换VO返回
List<UserVO> userVOList = new ArrayList<>(userList.size());
for (User user : userList) {
    // 3.1 转换UserPO为 VO
    UserVO vo = BeanUtil.copyProperties(user, UserVO.class);
    userVOlist.add(vo);
    // 3.2转换地址VO
    vo.setAddressVOList(addressMap.get(user.getId()));
}
```

### 状态字段的ENUM化

使用enmu类

```java
@Getter
public enum UserStatus {
    NORMAL(1, "正常"),
    FROZEN(2, "冻结"),
    ,
    @EnumValue
    private final int value;
    private final String desc;
    
    UserStatus(int value, String desc) {
        this.value = value;
        this.desc = desc;
    }
}
```

### JSON数据处理

对JSON化的数据项单独建个类

```java
@Data
@NoArgsConstructor
@AllArgsConstructor(staticName = "of")
public class UserInfo{
    private Integer age;
    private String intro;
    private String gender;
}
```

对实体类的JSON项进行注解

```java
@Data
@TableName(value = "user", autoResultMap = true)
public class User{
    /**
    *详细信息
    */
    @TableField(typeHandler = JasksonTypeHandler.class)
    private UserInfo info;
}
```

### 通用分页实体和MP转换

通用的PageQuery以UserQuery继承为例

```java
@EqualsAndHashCode(callSuper = true)
@Data
@ApiModel(description = "用户查询条件实体")
public class UserQuery extends PageQuery{
    @ApiModelProperty("用户关键字")
    private String name;
    @ApiModelProperty("用户状态：1-正常，2-冻结")
    private Integer status;
    @ApiModelProperty("余额最小值")
    private Integer minBalance;
    @ApiModelProperty("余额最大值")
    private Integer maxBalance;
}
```

```java
@Data
@ApiModel(description = "分页查询实体")
public class PageQuery{
    
    @ApiModelProperty("页码")
    private Integer pageNo = 1;
    @ApiModelProperty("页码")
    private Integer pageSize = 5;
    @ApiModelProperty("排序字段")
    private String sortBy;
    @ApiModelProperty("是否升序")
    private Boolean isAsc = true;
    
    public <T> Page<T> toMpPage(OrederItem ... itmes) {
        // 1.分页条件
        Page<T> page = Page.of(pageNo, pageSize);
        // 2.排序条件
        if(StrUtil.isNotBlank(sortBy)){
            //不为空
            page.addOrder(new OrderItem(sortBy, isAsc));
        }else if(items != null){
            // 为空，默认排序
            page.addOrder(items);
        }
        return page;
    }
    
    private <T> Page<T> toMpPage(String defaultSortBy, Boolean defaultAsc) {
        return toMpPage(new OrderItem(defaultSortBy, defaultAsc));
    }
    public <T> Page<T> toMpPageDefaultSortByCreateTime(){
        return toMpPage(new OrderItem("create_time", false));
    }
    public <T> Page<T> toMpPageDefaultSortByUpdateTime(){
        return toMpPage(new OrderItem("update_time", false));
    }
}
```

当PO和VO属性名相同时

```java
public static <PO, VO> pageDTO<VO> of(Page<PO> p, Class<VO> clazz){ // 泛型只是占位符不能获取它的字节符，所以需要调用者传入
    PageDTO<VO> dto = new PageDTO<>();
    // 1.总条数
    dto.setTotal(p.getTotal());
    // 2.总页数
	dto.setPages(p.getPages());
    // 3.当前页数据
    List<PO> records = p.getRecords();
    if (CollUtil.isEmpty(records)) {
        dto.setList(Collections.emptyList());
        return dto;
    }
    // 4.拷贝user的VO
    dto.setList(BeanUtil.copyToList(records, clazz));
    // 5.返回
    return dto;
}
```

当PO和VO属性名不同时

```java
public static <PO, VO> pageDTO<VO> of(Page<PO> p, Class<VO> clazz){ // 泛型只是占位符不能获取它的字节符，所以需要调用者传入
    PageDTO<VO> dto = new PageDTO<>();    
    // 1.总条数   
    dto.setTotal(p.getTotal());    
    // 2.总页数    
    dto.setPages(p.getPages());    
    // 3.当前页数据 
    List<PO> records = p.getRecords();    
    if (CollUtil.isEmpty(records)) {        dto.setList(Collections.emptyList());        return dto;    }    // 4.拷贝user的VO    
    dto.setList(records.stream().map(convertor).collect(Collectors.toList()));    
    // 5.返回    
    return dto;
}
```

调用案例

```java
@Override
Public PageDTO<UserVO> queryUsersPage(UserQuery query) {
    String name = query.getName();
    Integer status = query.getStatus();
    // 1.构建分页条件
    Page<User> page = query.toMpPageDefaultSortByUpdateTime();
    // 2.分页查询
    Page<User> p = lambdaQuery()
        			.like(name != null, User::getUsername, name)
        			.eq(status != null, User::getStatus, status)
        			.page(page);
    
    // 3.封装VO结果
    return PageDTO.of(p, user -> {
        // 1.拷贝基础属性
        UserVO vo = BeanUtil.copyProperties(user, UserVO.class);
        // 2.处理特殊逻辑
        vo.setUsername(vo.getUsername().subString(0, vo.getUsername().length() - 2) + "**");
        return vo;
    });
}
```

### 导入Bean

在类上加上@RequiredArgsConstructor

表示这个类在加载时要导入声明了final的属性

```java
@Service
@RequiredArgsConstructor
public class CartServiceImpl extends ServiceImpl<CartMapper, Cart> implements ICartService {
    
    private final RestTemplate  restTemplate;
}
```



# docker

```bash
docker run -d \
	--name mysql \
	-p 3306:3306 \
	-e TZ=Asia/Shanghai \
	-e MYSQL_ROOT_PASSWORD=123456 \
	mysql
```

- docker run: 创建并运行一个容器，-d 是让容器在后台运行
- --name mysql ：给容器起个名字，必须唯一
- -p 3306:3306 ：设置端口映射
- -e KEY=VALUE：是设置环境变量
- mysql：指定运行的镜像的名字

# 微服务

### 服务拆分原则

从拆分目标来说，要做到：

- 高内聚：每个微服务的职责要尽量单一，包含的业务相互关联度高、完整度高。
- 低耦合：每个微服务的功能要相对独立，尽量减少对其它微服务的依赖

拆分方式，两种方法：

- 纵向拆分：按照业务模块来拆分
- 横向拆分：抽取公共服务，提高复用性。

拆分后碰到的第一个问题是什么，如何解决？

- 拆分后，某些数据在不同服务，无法直接调用本地方法查询数据
- 利用RestTemplate发送Http请求，实现远程调用

# 远程调用

Spring给我们提供了一个RestTemplate工具，可以方便的实现Http请求的发送。使用步骤如下：

1. 注入RestTemplate到Spring容器

   ```java
   @Bean
   public RestTemplate restTemplate(){
       return new RestTemplate();
   }
   ```

2. 发起远程调用

   ```java
   public <T> ResponseEntity<T> exchange(
       String url, // 请求路径 -"http://localhost:8081/items?id={id}"
       HttpMethod method, // 请求方式	HttpMethod.GET
       @Nullable HttpEntity<?> requestEntity, // 请求实体，可以为空
       Class<T> responseType, // 返回值类型	User.class
       Map<String, ?> uriVariables // 请求参数	Map.of("id", "1")
   )
   ```

   实际调用案例

   ```java
   private void handleCartItems(List<CartVO> vos) {
       // 1.获取商品id
       Set<Long> itemIds = vos.stream().map(CartVO::getItemId).collect(Collectors.toSet());
       // 2.查询商品
       // List<ItemDTO> items= itemService.queryItemByIds(itemIds);
       // 2.1 利用RestTemplate 发起http请求，得到http的响应
       ResponseEntity<List<ItemDTO>> response = restTemplate.exchange(
       	"http://localhost:8081/items?ids={ids}",
           HttpMethod.GET,
           null,
           new ParameterizedTypeReference<List<ItemDTO>>(){},
           Map.of("ids",CollUtil.join(itemIds, ","))
       )
   }
   ```

   其中有几个点需要注意

   1. 在返回类型中由于比较复杂是一个LIST《ITEMDTO》的形式所以不能通过直接传一个class字节码来确定返回类型，所以使用new 一个类来解决
   2. 在Map的值中，由于对于Ids是一个字符串，不能用集合来传入，使用了hutool的工具CollUtil.join将集合内的参数以指定的字符连接起来，

