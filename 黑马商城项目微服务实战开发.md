# 黑马商城项目微服务实战开发

## 导入数据库

在黑马中导入数据使用docker进行自动化导入

```bash
docker run -d \
  --name mysql \
  -p 3307:3306 \
  -e TZ=Asia/Shanghai \
  -e MYSQL_ROOT_PASSWORD=123 \
  -v /root/mysql/data:/var/lib/mysql \
  -v /root/mysql/conf:/etc/mysql.conf.d \
  -v /root/mysql/init:/docker-entrypoint-initdb.d \
  --network hm-net \
  mysql
```

## 拆分服务

首先在父工程下新建个模块

然后把需要的依赖给引入

在新的工程的启动项上进行个注解

```java
@MapperScan("com.heima.item.mapper")
@SpringBootApplication
public class ItemServiceApplication {

    public static void main(String[] args) {
        SpringApplication.run(ItemServiceApplication.class, args);
    }

}
```

@MapperScan

作用：指定要变成实现类的接口所在的包，然后包下面的所有接口在编译之后都会生成相应的实现类

添加位置：是在SpringBoot启动类上面添加



#### 在配置中

需要注意的点:

1. 每个微服务名字各异
2. logging配置中
   1. level是输出级别
   2. fill-path 是文件的输出位置，保证每个服务的输出位置不同

```yaml
server:
  port: 8081
# 要给微服务起个名字
spring:
  application:
    name: item-service # 微服务名称
  profiles:
    active: dev
  datasource:
    url: jdbc:mysql://${hm.db.host}:3307/hmall?useUnicode=true&characterEncoding=UTF-8&autoReconnect=true&serverTimezone=Asia/Shanghai
    driver-class-name: com.mysql.cj.jdbc.Driver
    username: root
    password: ${hm.db.pw}
mybatis-plus:
  configuration:
    default-enum-type-handler: com.baomidou.mybatisplus.core.handlers.MybatisEnumTypeHandler
  global-config:
    db-config:
      update-strategy: not_null
      id-type: auto
logging:
  level:
    com.hmall: debug
  pattern:
    dateformat: HH:mm:ss:SSS
  file:
    path: "logs/${spring.application.name}"
knife4j:
  enable: true
  openapi:
    title: 黑马商城商品管理文档
    description: "黑马商城商品管理文档"
    email: zhanghuyi@itcast.cn
    concat: 虎哥
    url: https://www.itcast.cn
    version: v1.0.0
    group:
      default:
        group-name: default
        api-rule: package
        api-rule-resources:
          - com.heima.item.controller

```

## 注册中心

![image-20250116172100706](C:\Users\29326\AppData\Roaming\Typora\typora-user-images\image-20250116172100706.png)

**服务治理中的三个角色分别是什么？**

- 服务提供者：暴露服务接口，供其它服务调用
- 服务消费者：调用其它服务提供的接口
- 注册中心：记录并监控微服务各实例状态，推送服务变更信息

**消费者如何知道提供者的地址？**

- 服务提供者会在启动时注册自己信息到注册中心，消费者可以从注册中心订阅和拉取服务信息

**消费者如何得知服务状态变更？**

- 服务提供者通过心跳机制向注册中心报告自己的健康状态，当心跳异常时注册中心会将异常服务剔除，并通知订阅了该服务的消费者

**当提供者有多个实例时，消费者该选择哪一个？**

- 消费者可以通过负载均衡算法，从多个实例中选择一个

**服务发现**

## 最佳实现

![image-20250116203538032](C:\Users\29326\AppData\Roaming\Typora\typora-user-images\image-20250116203538032.png)

![image-20250116203654016](C:\Users\29326\AppData\Roaming\Typora\typora-user-images\image-20250116203654016.png)



当定义的FeignClient不在SpringBootApplication的扫描包范围时，这些FeignClient无法使用。有两种方式解决：

方法一：指定FeignClient所在包

```java
@EnableFeignClients(basePackages = "com.hmall.api.clients")
```

方法二：指定FeignClient字节码

```java
@EnableFeignClients(clients = {UserClient.class})
```



# 实用的点

### 工具类

其中的BeanUtil 很好用

```xml
<dependency>
            <groupId>cn.hutool</groupId>
            <artifactId>hutool-core</artifactId>
            <version>5.8.35</version>
</dependency>
```

### mybatisplus实用插件使用

![image-20250112174704016](C:\Users\29326\AppData\Roaming\Typora\typora-user-images\image-20250112174704016.png)

### 查询集合时判空使用

```java
CollUtil.isEmpty(list);
// 为空的话返回一个
Collections.emptyList();
```



```java
// 已知ids获取对应用户
List<User> userList = listByIds(ids);
// 1获取用户id集合
List<Long> idList = userList.lambda().map(User::getId).collect(Collectors.toList());

// 2根据用户id查询地址
List<Address> address = Db.lambdaQuery(Address.class).in(Address::getUserId, userIds).list();
// 2.1获取用户id集合
List<Long> idList = userList.stream().map(User::getId).toList();
// 2.2根据用户id查询地址
List<Address> addressList = Db.lambdaQuery(Address.class).in(Address::getUserId, idList).lsit();
// 2.3转换地址VO
List<AddressVO> addressVOS = BeanUtil.copyToList(addressList, AddressVO.class);
// 2.4用户地址集合分组处理，相同用户的放入一个集合（组）中
Map<Long, List<AddressVO>> addressMap = new HashMap<>(0);
if(CollUtil.isNotEmpty(addressList)){
    addressMap = addressMap.stream().collect(Collectors.groupingBy(AddressVO::getUserId));
}
// 3.转换VO返回
List<UserVO> userVOList = new ArrayList<>(userList.size());
for (User user : userList) {
    // 3.1 转换UserPO为 VO
    UserVO vo = BeanUtil.copyProperties(user, UserVO.class);
    userVOlist.add(vo);
    // 3.2转换地址VO
    vo.setAddressVOList(addressMap.get(user.getId()));
}
```

### 状态字段的ENUM化

使用enmu类

```java
@Getter
public enum UserStatus {
    NORMAL(1, "正常"),
    FROZEN(2, "冻结"),
    ,
    @EnumValue
    private final int value;
    private final String desc;
    
    UserStatus(int value, String desc) {
        this.value = value;
        this.desc = desc;
    }
}
```

### JSON数据处理

对JSON化的数据项单独建个类

```java
@Data
@NoArgsConstructor
@AllArgsConstructor(staticName = "of")
public class UserInfo{
    private Integer age;
    private String intro;
    private String gender;
}
```

对实体类的JSON项进行注解

```java
@Data
@TableName(value = "user", autoResultMap = true)
public class User{
    /**
    *详细信息
    */
    @TableField(typeHandler = JasksonTypeHandler.class)
    private UserInfo info;
}
```

### 通用分页实体和MP转换

通用的PageQuery以UserQuery继承为例

```java
@EqualsAndHashCode(callSuper = true)
@Data
@ApiModel(description = "用户查询条件实体")
public class UserQuery extends PageQuery{
    @ApiModelProperty("用户关键字")
    private String name;
    @ApiModelProperty("用户状态：1-正常，2-冻结")
    private Integer status;
    @ApiModelProperty("余额最小值")
    private Integer minBalance;
    @ApiModelProperty("余额最大值")
    private Integer maxBalance;
}
```

```java
@Data
@ApiModel(description = "分页查询实体")
public class PageQuery{
    
    @ApiModelProperty("页码")
    private Integer pageNo = 1;
    @ApiModelProperty("页码")
    private Integer pageSize = 5;
    @ApiModelProperty("排序字段")
    private String sortBy;
    @ApiModelProperty("是否升序")
    private Boolean isAsc = true;
    
    public <T> Page<T> toMpPage(OrederItem ... itmes) {
        // 1.分页条件
        Page<T> page = Page.of(pageNo, pageSize);
        // 2.排序条件
        if(StrUtil.isNotBlank(sortBy)){
            //不为空
            page.addOrder(new OrderItem(sortBy, isAsc));
        }else if(items != null){
            // 为空，默认排序
            page.addOrder(items);
        }
        return page;
    }
    
    private <T> Page<T> toMpPage(String defaultSortBy, Boolean defaultAsc) {
        return toMpPage(new OrderItem(defaultSortBy, defaultAsc));
    }
    public <T> Page<T> toMpPageDefaultSortByCreateTime(){
        return toMpPage(new OrderItem("create_time", false));
    }
    public <T> Page<T> toMpPageDefaultSortByUpdateTime(){
        return toMpPage(new OrderItem("update_time", false));
    }
}
```

当PO和VO属性名相同时

```java
public static <PO, VO> pageDTO<VO> of(Page<PO> p, Class<VO> clazz){ // 泛型只是占位符不能获取它的字节符，所以需要调用者传入
    PageDTO<VO> dto = new PageDTO<>();
    // 1.总条数
    dto.setTotal(p.getTotal());
    // 2.总页数
	dto.setPages(p.getPages());
    // 3.当前页数据
    List<PO> records = p.getRecords();
    if (CollUtil.isEmpty(records)) {
        dto.setList(Collections.emptyList());
        return dto;
    }
    // 4.拷贝user的VO
    dto.setList(BeanUtil.copyToList(records, clazz));
    // 5.返回
    return dto;
}
```

当PO和VO属性名不同时

```java
public static <PO, VO> pageDTO<VO> of(Page<PO> p, Class<VO> clazz){ // 泛型只是占位符不能获取它的字节符，所以需要调用者传入
    PageDTO<VO> dto = new PageDTO<>();    
    // 1.总条数   
    dto.setTotal(p.getTotal());    
    // 2.总页数    
    dto.setPages(p.getPages());    
    // 3.当前页数据 
    List<PO> records = p.getRecords();    
    if (CollUtil.isEmpty(records)) {        dto.setList(Collections.emptyList());        return dto;    }    // 4.拷贝user的VO    
    dto.setList(records.stream().map(convertor).collect(Collectors.toList()));    
    // 5.返回    
    return dto;
}
```

调用案例

```java
@Override
Public PageDTO<UserVO> queryUsersPage(UserQuery query) {
    String name = query.getName();
    Integer status = query.getStatus();
    // 1.构建分页条件
    Page<User> page = query.toMpPageDefaultSortByUpdateTime();
    // 2.分页查询
    Page<User> p = lambdaQuery()
        			.like(name != null, User::getUsername, name)
        			.eq(status != null, User::getStatus, status)
        			.page(page);
    
    // 3.封装VO结果
    return PageDTO.of(p, user -> {
        // 1.拷贝基础属性
        UserVO vo = BeanUtil.copyProperties(user, UserVO.class);
        // 2.处理特殊逻辑
        vo.setUsername(vo.getUsername().subString(0, vo.getUsername().length() - 2) + "**");
        return vo;
    });
}
```

### 导入Bean

在类上加上@RequiredArgsConstructor

表示这个类在加载时要导入声明了final的属性

```java
@Service
@RequiredArgsConstructor
public class CartServiceImpl extends ServiceImpl<CartMapper, Cart> implements ICartService {
    
    private final RestTemplate  restTemplate;
}
```



# docker

```bash
docker run -d \
	--name mysql \
	-p 3306:3306 \
	-e TZ=Asia/Shanghai \
	-e MYSQL_ROOT_PASSWORD=123456 \
	mysql
```

- docker run: 创建并运行一个容器，-d 是让容器在后台运行
- --name mysql ：给容器起个名字，必须唯一
- -p 3306:3306 ：设置端口映射
- -e KEY=VALUE：是设置环境变量
- mysql：指定运行的镜像的名字

# 微服务

### 服务拆分原则

从拆分目标来说，要做到：

- 高内聚：每个微服务的职责要尽量单一，包含的业务相互关联度高、完整度高。
- 低耦合：每个微服务的功能要相对独立，尽量减少对其它微服务的依赖

拆分方式，两种方法：

- 纵向拆分：按照业务模块来拆分
- 横向拆分：抽取公共服务，提高复用性。

拆分后碰到的第一个问题是什么，如何解决？

- 拆分后，某些数据在不同服务，无法直接调用本地方法查询数据
- 利用RestTemplate发送Http请求，实现远程调用

# 远程调用

Spring给我们提供了一个RestTemplate工具，可以方便的实现Http请求的发送。使用步骤如下：

1. 注入RestTemplate到Spring容器

   ```java
   @Bean
   public RestTemplate restTemplate(){
       return new RestTemplate();
   }
   ```

2. 发起远程调用

   ```java
   public <T> ResponseEntity<T> exchange(
       String url, // 请求路径 -"http://localhost:8081/items?id={id}"
       HttpMethod method, // 请求方式	HttpMethod.GET
       @Nullable HttpEntity<?> requestEntity, // 请求实体，可以为空
       Class<T> responseType, // 返回值类型	User.class
       Map<String, ?> uriVariables // 请求参数	Map.of("id", "1")
   )
   ```

   实际调用案例

   ```java
   private void handleCartItems(List<CartVO> vos) {
       // 1.获取商品id
       Set<Long> itemIds = vos.stream().map(CartVO::getItemId).collect(Collectors.toSet());
       // 2.查询商品
       // List<ItemDTO> items= itemService.queryItemByIds(itemIds);
       // 2.1 利用RestTemplate 发起http请求，得到http的响应
       ResponseEntity<List<ItemDTO>> response = restTemplate.exchange(
       	"http://localhost:8081/items?ids={ids}",
           HttpMethod.GET,
           null,
           new ParameterizedTypeReference<List<ItemDTO>>(){},
           Map.of("ids",CollUtil.join(itemIds, ","))
       )
   }
   ```

   其中有几个点需要注意

   1. 在返回类型中由于比较复杂是一个LIST《ITEMDTO》的形式所以不能通过直接传一个class字节码来确定返回类型，所以使用new 一个类来解决
   2. 在Map的值中，由于对于Ids是一个字符串，不能用集合来传入，使用了hutool的工具CollUtil.join将集合内的参数以指定的字符连接起来，

# Nacos注册中心

Nacos是目前国内企业中占比最多的注册中心组件。它是阿里巴巴的产品，目前已经加入SpringCloudAlibaba中。

使用步骤

1. 导入nacos的数据库

2. 将`nacos/custom.env`的配置放入root目录

   ```
   PREFER_HOST_MODE=hostname
   MODE=standalone
   SPRING_DATASOURCE_PLATFORM=mysql
   MYSQL_SERVICE_HOST=	//改成自己数据库的地址
   MYSQL_SERVICE_DB_NAME=nacos
   MYSQL_SERVICE_PORT=3307	//改成自己数据库的端口
   MYSQL_SERVICE_USER=root	//改成自己数据库的姓名
   MYSQL_SERVICE_PASSWORD=123	//改成自己数据库的密码
   MYSQL_SERVICE_DB_PARAM=characterEncoding=utf8&connectTimeout=1000&socketTimeout=3000&autoReconnect=true&useSSL=false&allowPublicKeyRetrieval=true&serverTimezone=Asia/Shanghai
   ```

3. 使用docker指令进行容器配置运行

   ```bash
   docker run -d \
   --name nacos \
   --env-file ./nacos/custom.env \
   -p 8848:8848 \
   -p 9848:9848 \
   -p 9849:9849 \
   --restart=always \
   nacos/nacos-server:v2.1.0-slim
   ```

   8848 是用于客户端与服务通信的主要端口。

   9848 是 gRPC 端口，用于与 Nacos 的 gRPC 通信（如果需要）。

   9849 是 Raft 端口，用于 Nacos 集群中节点之间的通信（如果运行集群模式）。

   启动完成后，访问下面地址：http://192.168.150.101:8848/nacos/，注意将`192.168.150.101`替换为你自己的虚拟机IP地址。

   首次访问会跳转到登录页，**账号密码都是nacos**

4. **服务注册**

   1. 引入依赖

      ```xml
      <!--nacos 服务注册发现-->
      <dependency>
      	<groupId>com.alibaba.cloud</groupId>
          <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>
      </dependency>
      ```

   2. 配置Nacos地址

      ```yaml
      spring:
      	application:
      		name: item-service # 服务名称
      	cloud:
      		nacos:
      			server-addr: 192.168.150.101:8848 # nacos地址
      ```

5. **服务发现**

   **消费者**需要连接nacos以拉取和订阅服务，因此服务发现的前两步与服务注册是一样的，后面再加上服务调用即可：

   1. 引入 nacos discovery依赖

   2. 配置nacos地址

   3. 服务发现

      ```java
      private final DiscoveryClient discoveryClient;
      
      private void handleCartItems(List<CartVO> vos) {
          // 1.根据服务名称，拉取服务的实例列表
          List<ServiceInstance> instances = discoveryClient.getInstances("item-service");
          // 2.负载均衡，挑选一个实例
          ServiceInstance instance = instances.get(RandomUtil.randomInt(instances.size()));//传入一个负载均衡算法
          // 3.获取实例的IP和端口
          URI uri = instance.getUri();
          // ... 略
      }
      ```

## OpenFeign

OpenFeign是一个声明式的http客户端，是SpringCloud在Eureka公司开源的Feign基础上改造而来

原始的方法：

![image-20250116185255943](C:\Users\29326\AppData\Roaming\Typora\typora-user-images\image-20250116185255943.png)

使用方法：

OpenFeign已经被SpringCloud自动装配，实现起来非常简单：

1. 引入依赖，包括OpenFeign和负载均衡组件SpringCloudLoadBalancer

   ```xml
   <!--OpenFeign-->
   <dependency>
   	<groupId>org.springframework.cloud</groupId>
       <artifactId>spring-cloud-starter-openfeign</artifactId>
   </dependency>
   <!--负载均衡-->
   <dependency>
   	<groupId>org.springframework.cloud</groupId>
       <artifactId>spring-cloud-starter-loadbalancer</artifactId>
   </dependency>
   ```

   springCloud原本用的是Ribbon而此项目用的是最新的loadbalancer

2. 通过@EnableFeignClients注解，启用OpenFeign功能

   ```java
   @EnableFeignClients
   @SpringBootApplication
   public class CartApplication {}
   ```

3. 编写FeignClient

   ```java
   @FeignClient(value = "item-service")
   public interface ItemClient {
       @GetMapping("/items")
       List<ItemDTO> queryItemByIds(@RequestParam("ids" Collection<Long> ids));
   }
   ```

   

4. 使用FeignClient,实现远程调用

   ```java
   List<ItemDTO> items = itemClient.queryItemByIds(List.of(1,2,3));
   ```

## 连接池

OpenFeign对Http请求做了优雅的伪装，不过其底层发起了http请求，依赖于其它的框架。这些框架可以自己选择，包括以下三种：

- HttpURLConnection: 默认实现，不支持连接池
- Apache HttpClient：支持连接池
- OKHttp支持连接池

OpenFeign整合OKHttp的步骤如下：

1. 引入依赖

   ```xml
   <!--ok-http-->
   <dependency>
   	<groupId>io.github.openfeign</groupId>
       <artifactId>feign-okhttp</artifactId>
   </dependency>
   ```

2. 开启连接池功能

   ```yaml
   feign:
   	okhttp:
   		enabled: true # 开启OKHttp连接池支持
   ```

   

## 日志

OpenFeign 只会在FeignClient所在包的日志级别为DEBUG时，才会输出日志。而且其日志级别有4级：

- **NONE**：不记录任何日志信息，这是默认值。
- **BASIC**：仅记录请求的方法，URL以及响应状态码和执行时间
- **HEADERS**：在BASIC的基础上，额外记录了请求和响应的头信息
- **FULL**：记录所有请求和响应的明细，包括头信息、请求体、元数据

由于Fegin默认的日志级别就是NONE，所以默认我们看不到请求日志

要自定义日志级别需要声明一个类型为Logger.Level的Bean，在其中定义日志级别：

```java
public class DefaultFeignConfig {
    @Bean
    public Logger.Level feignLogLevel(){
        return Logger.Level.FULL;
    }
}
```

但此时这个Bean并未生效，要想配置某个FeignClient的日志，可以在@FeignClient注解中声明：

```java
@FeignClient(value = "item-service", configuration = DefaultFeignConfig.class)
```

如果想要**全局配置**，让所有FeignClient都按照这个日志配置，则需要在@EnableFeignClients注解中声明：

```java
@EnableFeignClients(defaultConfiguration = DefaultFeignConfig.class)
```

